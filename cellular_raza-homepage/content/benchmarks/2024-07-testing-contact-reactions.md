---
title: Accuracy Testing of Contact Reactions
date: 2024-07-23
math: true
---

`cellular_raza 0.1.12` [introduced](/internals/releases) the new simulation aspect of
[`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) which can couple the
intracellular reactions of individual cells.
Testing the individual Adams-Bashforth solver which is used in the contact reactions update function
[`reactions_contact_adams_bashforth_2nd`](/docs/cellular_raza_core/backend/chili/fn.reactions_contact_adams_bashforth_2nd.html)
is part of a different testing approach.
In contrast, these tests take a high-level view and aim to match known results for a complete system
onto results generated by `cellular_raza`.

## Two-Component Uncoupled System
### Theoretical Formulation
The first test ensures that a system of two components given by

$$\\begin{align}
    \dot{x}(t) &= f(x) = \alpha\\\\
    \dot{y}(t) &= g(y) = \alpha y \\left(1 - \\frac{y}{y_\\text{max}} \\right)
\\end{align}$$

is correctly solved and no unintended coupling is introduced.
These equations correspond to linear growth for $x(t)$ and the well-known logistic curve
[\[1\]](#References) in $y(t)$.
The analytical solutions to these equations are given by

$$\\begin{align}
    x(t) &= \alpha(t-t_0)\\\\
    y(t) &= y_\text{max}\left(1+ \frac{y_\text{max}-y_0}{y_0} e^{-\alpha(t-t_0)} \right)^{-1}.
\\end{align}$$

### Implementation in `cellular_raza`
To model them with `cellular_raza` we define a new agent type `ContactCell`.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=197}
use cellular_raza::building_blocks::*;
use cellular_raza::concepts::*;
use cellular_raza::core::{backend::chili::*, storage::*, time::*};

use serde::{Deserialize, Serialize};

#[derive(CellAgent, Clone, Debug, Deserialize, Serialize)]
struct ContactCell {
    intracellular: nalgebra::Vector2<f64>,
    alpha0: f64,
    upper_limit: f64,
    #[Position]
    mechanics: NewtonDamped1DF32,
}
```
Notice that the `mechanics: NewtonDamped1DF32` component only serves as the positional information
such that we can use the predefined
[`CartesianCuboid`](/docs/cellular_raza_building_blocks/struct.CartesianCuboid.html) as the simulation domain.
Furthermore, we implement the required concepts
[`Intracellular`](/docs/cellular_raza_concepts/trait.Intracellular.html),
[`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) as follows.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=211}
impl Intracellular<nalgebra::Vector2<f64>> for ContactCell {
    fn get_intracellular(&self) -> nalgebra::Vector2<f64> {
        self.intracellular
    }
    fn set_intracellular(&mut self, intracellular: nalgebra::Vector2<f64>) {
        self.intracellular = intracellular;
    }
}

impl ReactionsContact<nalgebra::Vector2<f64>, nalgebra::Vector1<f32>> for ContactCell {
    fn calculate_contact_increment(
        &self,
        own_intracellular: &nalgebra::Vector2<f64>,
        ext_intracellular: &nalgebra::Vector2<f64>,
        _own_pos: &nalgebra::Vector1<f32>,
        _ext_pos: &nalgebra::Vector1<f32>,
        _rinf: &(),
    ) -> Result<(nalgebra::Vector2<f64>, nalgebra::Vector2<f64>), CalcError> {
        let calculate_incr = |y: f64| -> f64 { self.alpha0 * y * (1.0 - y / self.upper_limit) };
        let own_dr = [self.alpha0, calculate_incr(own_intracellular[1])].into();
        let ext_dr = [self.alpha0, calculate_incr(ext_intracellular[1])].into();
        Ok((own_dr, ext_dr))
    }
    fn get_contact_information(&self) -> () {}
}
```

The [`ReactionsContact`](/docs/cellular_raza_concepts/trait.ReactionsContact.html) trait requires
that agents interact with each other, meaning we have to at least insert 2 agents into the
simulation to obtain any effect.
Since we employ no restraints on the range of interaction by not using the values `_own_pos` or
`_ext_pos` in the `calculate_contact_increment` function, every cell will interact with each other.
This also results in an increased reaction speed when more than 2 cells are present, meaning our
variable $\alpha$ for the exact solution is actually dependent on the number of species.

$$\begin{equation}
    \alpha = (N_\text{agents}-1)\alpha_0
\end{equation}$$

We have named the variable of the individual agents accordingly.

### Solving the System
Now we are ready to solve our system with the
[`run_simulation!`](/docs/cellular_raza_core::backend::chili::run_simulation) macro.
To test various configurations, we write a function which takes in all needed parameters to solve the system.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=237}
fn run_cellular_raza(
    alpha0: f64,
    y0: [f64; 2],
    upper_limit: f64,
    n_agents: usize,
    t0: f64,
    dt: f64,
    save_interval: usize,
    t_max: f64,
) -> Result<Vec<(f64, Vec<[f64; 2]>)>, SimulationError> {
    // Define initial values
    let y0 = nalgebra::Vector2::from(y0);

    // Agents
    let agents = (0..n_agents).map(|_| ContactCell {
        alpha0,
        intracellular: y0,
        upper_limit,
        mechanics: NewtonDamped1DF32 {
            pos: [0.5].into(),
            vel: [0.0].into(),
            damping_constant: 0.0,
            mass: 0.0,
        },
    });

    // Specify simulation domain, time and only store results intermediately in memory
    let domain = CartesianCuboid::from_boundaries_and_n_voxels([0.0; 1], [1.0; 1], [1; 1])?;
    let time = FixedStepsize::from_partial_save_freq(t0, dt, t_max, save_interval)?;
    let storage = StorageBuilder::new().priority([StorageOption::Memory]);
    let settings = Settings {
        n_threads: 1.try_into().unwrap(),
        show_progressbar: false,
        storage,
        time,
    };

    // Run full simulation and return storager to access results
    let storager = run_simulation!(
        agents: agents,
        settings: settings,
        domain: domain,
        aspects: [ReactionsContact],
    )?;

    // Gather cellular_raza results
    Ok(storager
        .cells
        .load_all_elements()?
        .into_iter()
        .map(|(iteration, elements)| {
            (
                t0 + iteration as f64 * dt,
                elements
                    .into_iter()
                    .map(|(_, (cbox, _))| cbox.cell.get_intracellular().into())
                    .collect(),
            )
        })
        .collect())
}
```

### Comparing Results
In order to meaningfully compare numerical results, we need an estimate for the local and global
truncation error [\[2\]](#References) which is introduced by our numerical solver.
For a given ODE in the form of 

$$\begin{equation}
    \dot{y} = f(t, y)
\end{equation}$$

which can be solved by an algorithm $A$ in the form of

$$\begin{equation}
    y_n = y_{n-1} + \Delta t A(t_{n-1}, y_{n-1}, \Delta t, f)
\end{equation}$$

the local truncation error $\tau_n$ is given by

$$\begin{equation}
    \tau_n = y(t_n) - y(t_{n-1}) - \Delta t A(t_{n-1}, y_{n-1}, \Delta t, f)
\end{equation}$$

and is related to the global truncation error $e_n$ via

$$\begin{align}
    e_n &= y(t_n) - y_n\\\\
        &= y(t_n) - (y_0 + \Delta A(t_0, y_0, \Delta t, f) + \dots + \Delta t A(t_{n-1},y_{n-1},\Delta t, f).
\end{align}$$

Under the additional condition that $f$ is Lipschitz with Lipschitz-constant $L$, we can derive a
bound for the global error.

$$\begin{equation}
    |e_n| \leq \frac{\text{max}_j \tau_j}{\Delta t L}\left(e^{L(t-t_0)} + 1 \right)
\end{equation}$$

where $\tau_n$ is the local truncation error at time step $n$.
By finding an upper bound for it, we can further simplify this formula.
The local truncation error $\tau_n$ depends on the type of solver used.
In our case, we employ the Adams-Bashforth [\[3\]](#References) solver with 3rd order.
The executed function in the [chili](/itnernals/backend/chili) backend is
[`contact_reactions_adams_bashforth_3rd`](/docs/cellular_raza_core/backend/chili/fn.reactions_contact_adams_bashforth_3rd.html).
The local truncation error is bound

$$\begin{equation}
    |\tau_n| \leq \frac{3\Delta t^4}{8}\sup\limits_{t\in(t_n-2\Delta t,x_n+\Delta t)}|y^{(4)}(t)|
\end{equation}$$

where $y^{(4)}(t)$ is the fourth-order derivative of the analytical solution $y$.
We can calculate this value for both ODEs by differentiating equations $(3)$ and $(4)$.

$$\begin{align}
    x^{(n)}(t) &= 0\\\\
    y^{(n)}(t) &= n! y_\text{max} \alpha^n\left(\frac{y_\text{max}-y_0}{y_0}\right)^n
        \left(1+\frac{y_\text{max}-y_0}{y_0}e^{-\alpha(t-t_0)}\right)^{-(n+1)}\\\\
\end{align}$$

With this upper bound on the local truncation error we can construct a new function which tests
that this upper bound is fulfilled.
We begin by writing down a general formula for the nth drivative of the exact solution to the
logistic curve ODE problem as given above.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=299}
fn compare_results(
    production: f64,
    y0: [f64; 2],
    upper_limit: f64,
    n_agents: usize,
    t0: f64,
    dt: f64,
    save_interval: usize,
    t_max: f64,
    #[allow(unused)] save_filename: &str,
) -> Result<(), SimulationError> {
    // Define exact solution
    let q = (upper_limit - y0[1]) / y0[1];
    let exact_solution_derivative = |t: f64, n_deriv: i32| -> nalgebra::Vector2<f64> {
        let linear_growth = if n_deriv == 0 {
            y0[0] + (n_agents - 1) as f64 * production * (t - t0)
        } else {
            0.0
        };
        let logistic_curve = (1..n_deriv).product::<i32>() as f64
            * upper_limit
            * q.powi(n_deriv)
            * (1.0 + q * (-production * (n_agents - 1) as f64 * (t - t0)).exp())
                .powi(-(n_deriv + 1));
        nalgebra::Vector2::from([linear_growth, logistic_curve])
    };

    // ...
```

In the next step we calculate the Lipschitz-constants $L_0,L_1$ and use them together with the
fourth derivative bound to calculate the local and global truncation errors.
The Lipschitz condition is given by

$$\begin{equation}
    |f(s) - f(t)| \leq L |s-t|
\end{equation}$$

In our case, we can use 

```rust {filename="contact_reactions.rs", linenos=table, linenostart=324}
    // ...

    // Estimate upper bound on local and global truncation error
    let lipschitz_constant = nalgebra::vector![
        (n_agents - 1) as f64 * production,
        y0[1] / (t_max - t0)
            * (1.0 / (1.0 + q * (-production * (n_agents - 1) as f64 * t0).exp())
                - 1.0 / (1.0 + q * (-production * (n_agents - 1) as f64 * (t_max - t0)).exp()))
            .abs()
            .max(10.0 * std::f64::EPSILON)
    ];
    let fourth_derivative_bound = |t: f64| -> nalgebra::Vector2<f64> {
        nalgebra::vector![
            // This should be zero but due to machine precision we need to insert something here.
            // Since we are doing multiple operations such as add, multiply etc. we need more than
            // the minimal amount of precision
            80.0 * f64::EPSILON,
            exact_solution_derivative((t - 2.0 * dt).min(t0), 4)[1]
        ]
    };

    // Calculate upper bound on local and global truncation error
    let local_truncation_error = |t: f64| -> nalgebra::Vector2<f64> {
        &fourth_derivative_bound(t) * (3f64 / 8.0 * dt.powi(4))
    };
    let global_truncation_error = |t: f64| -> nalgebra::Vector2<f64> {
        nalgebra::Vector2::from([
            ((lipschitz_constant[0] * t).exp() - 1.0) * local_truncation_error(t)[0]
                / dt
                / lipschitz_constant[0],
            ((lipschitz_constant[1] * t).exp() - 1.0) * local_truncation_error(t)[1]
                / dt
                / lipschitz_constant[1],
        ])
    };

    // ...
```
In the final step, we use the already defined function `` to generate results from `cellular_raza`
and compare them with the exact known results.
Their difference has to be within the margin of the calculated global truncation error $e$.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=358}
    // ...

    // Obtain solutions from cellular_raza
    let solutions_cr = run_cellular_raza(
        production,
        y0,
        upper_limit,
        n_agents,
        t0,
        dt,
        save_interval,
        t_max,
    )?;

    // Compare the results
    let mut results = vec![];
    for (t, res_cr) in solutions_cr {
        let res_ex = exact_solution_derivative(t, 0);
        let e_global = global_truncation_error(t);
        let e_local = local_truncation_error(t);
        for r in res_cr.iter() {
            let d0 = (r[0] - res_ex[0]).abs();
            let d1 = (r[1] - res_ex[1]).abs();
            assert!(d0 < e_global[0]);
            assert!(d1 < e_global[1]);
        }
        results.push((t, res_ex, e_global, e_local, res_cr));
    }

    #[cfg(not(debug_assertions))]
    save_results(results, save_filename);

    Ok(())
}
```

In the last step, we also added a function `save_results` which exports all generated results to a
`.csv` file which.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=393}
#[allow(unused)]
fn save_results(
    results: Vec<(
        f64,
        nalgebra::Vector2<f64>,
        nalgebra::Vector2<f64>,
        nalgebra::Vector2<f64>,
        Vec<[f64; 2]>,
    )>,
    save_filename: &str,
) {
    use std::fs::File;
    use std::io::prelude::*;
    let mut file = File::create(save_filename).unwrap();
    for (t, res_ex, e_global, e_local, res_cr) in results {
        write!(
            file,
            "{},{},{},{},{},{},{}",
            t, e_global[0], e_global[1], e_local[0], e_local[1], res_ex[0], res_ex[1]
        )
        .unwrap();
        for r_cr in res_cr {
            write!(file, ",{},{}", r_cr[0], r_cr[1]).unwrap();
        }
        writeln!(file, "").unwrap();
    }
}
```

Equipped with this function `compare_results`, we can now use it for a collection of configurations
to test the solver.

```rust {filename="contact_reactions.rs", linenos=table, linenostart=421}
#[test]
fn test_config0() {
    // Simulation parameters
    let production = 0.2;
    let y0 = [1.0, 2.0];
    let upper_limit = 12.0;
    let t0 = 3.0;
    let dt = 0.21;
    let save_interval = 2;
    let t_max = 20.000001;
    let n_agents = 2;
    compare_results(
        production,
        y0,
        upper_limit,
        n_agents,
        t0,
        dt,
        save_interval,
        t_max,
        "tests/contact_reactions-config0.csv",
    )
    .unwrap();
}
```

The generated files can then be used by a small python script to create the plots seen below.

```python {filename="plot.py", linenos=table}
import matplotlib.pyplot as plt
import numpy as np
from glob import glob

if __name__ == "__main__":
    files = glob("tests/*.csv")

    for file in files:
        # One line in such a file has the following entries
        # (
        #   t,
        #   gerror_bound0, gerror_bound1,
        #   lerror_bound0, lerror_bound1,
        #   res_exact0, res_exact_1,
        #   res_cr0_0, res_cr1_0,
        #   res_cr1_0, res_cr1_1,
        #   ...
        # )
        results = np.genfromtxt(file, delimiter=",")

        t = results[:,0]
        gerror = results[:,2]
        lerror = results[:,4]
        res_exact = results[:,6]

        fig, ax = plt.subplots()
        for n in range(7, results.shape[1]):
            if n % 2 == 0:
                ax.plot(t, results[:,n], label="Solution {:1.0f}".format(n), linestyle="--")
        ax.errorbar(
            t,
            res_exact,
            gerror,
            label="Analytical Solution",
            linestyle=":",
            color="k",
            alpha=0.5
        )
        ax.set_title("cellular_raza/" + str(file))
        ax.legend()
        fig.tight_layout()
        fig.savefig(file.replace(".csv", ".png"))
```

The full code can be found under
[`cellular_raza/tests/contact_reactions.rs`](https://github.com/jonaspleyer/cellular_raza/tree/master/cellular_raza/tests/contact_reactions.rs).
To run it yourself, clone the git repo `git clone https://github.com/jonaspleyer/cellular_raza` and
execute `cargo test -- two_component_contact_reaction` in the `cellular_raza` repository directory.

## Results

The following plots she the calculated results from `cellular_raza` and the analytical solution of
the second ODE described above in equation $(2)$ for various configurations of parameters.
They have been chosen in such a way to capture different dynamics and time-scales.
The global truncation error is used as errorbars for the analytical solution.

In the first image, we can clearly see the exponential growth of the global truncation error $e$
over time.
The size of the errorbars is mainly determined by the time interval $\Delta t$ chosen to solve the
equations.
The second studied example `config1` shows how a low step-size $\Delta t$ yields results which
follow the trajectory of the analytical solution to an even higher margin of error than before.
Only for the last case of `config2`, we can see a visually meaningful discrepancy between the
analytical solution and the numerical result.
In the very beginning, the initial ascend of the curve is overestimated and thus a faster growth
than the analytical solution can be seen.
However, this difference is still within the margin of error of our solver and the.

The initial overestimation can be explained by the internals of our implementation of the
Adams-Bashforth [\[3\]](#References) solver.
The numerical solver does not have any knowledge about the increments $\Delta y_n$ before the
simulation has started (ie. $n<0$).
It is thus forced to assume nothing and reverts back to the 1st order case.
For the second simulation step, the 2nd order Adams-Bashforth solver can be used and only
afterwards do we have enough information about previous time increments such that the full 3rd order
solver can take over.
This overestimation is only to be expected in the very initial steps of our numerical routine.

![](/benchmarks/contact_reactions/contact_reactions-config0.png)
![](/benchmarks/contact_reactions/contact_reactions-config1.png)
![](/benchmarks/contact_reactions/contact_reactions-config2.png)

## Discussion
We have shown how to derive useful bounds for the local and global truncation error of a result
with a known analytical solution.
Furthermore, these mathematical results have been implemented in an automated testing scheme to
measure and verify the solvers behind the `ReactionsContact` simulation aspect of `cellular_raza`.

## References
[1]
P. F. Verhulst,
“Recherches mathématiques sur la loi d’accroissement de la population.”
Nouveaux mémoires de l’Académie Royale des Sciences et Belles-Lettres de Bruxelles,
vol. 18, pp. 14–54, 1845,
[Online]. Available: [http://eudml.org/doc/182533](http://eudml.org/doc/182533)

[2]
E. Süli and D. F. Mayers,
“An Introduction to Numerical Analysis.”
Cambridge University Press,
Aug. 28, 2003.
doi: [10.1017/cbo9780511801181](https://doi.org/10.1017/CBO9780511801181)

[3]
Bashforth, Francis and Adams, J. Couch
An attempt to test the theories of capillary action : by comparing the theoretical and measured
forms of drops of fluid.
Cambridge [Eng.]: [Cambridge University Press, 1883](https://search.worldcat.org/title/1040022820)

[4]
G. Fasshauer,
“Numerical Methods for Differential Equations/Computational Mathematics II,”
2007,
[Online]. Available: [http://www.math.iit.edu/~fass/478578_Chapter_2.pdf](http://www.math.iit.edu/~fass/478578_Chapter_2.pdf)

